---
title: '『nand2tetris』を完走した感想とお気持ち表明'
date: '2021-05-15'
description: 'nand2tetrisを完走した感想とお気持ち表明'
tags: ['CPU','Assembler','Compiler','OS']
---

## はじめに
nand2tetrisという愛称で親しまれている書籍がある。正式名称は「[コンピュータシステムの理論と実装 ―モダンなコンピュータの作り方](https://amzn.to/3tLCMQ1)」という。この本の一貫したテーマは「nand回路さえあればand回路等各種論理回路を構築できる。各論理回路が構築できれば制御回路が構築できる。故にALUが構築でき、CPUが構築できる。文法さえ与えてやれば機械語を通してこのCPUを動かすことができ、アセンブラを構築できればアセンブリ言語を機械語に翻訳できる。etc...。このように演繹的に考えてみると、nand回路さえあれば理屈上OSを動かすことができることになる。それならばnand回路が所与として与えられている前提で自作OSでtetrisゲームが動かせるところまでエミュレータの力を借りながら登って行こうではないか。」というものである。nand2tetris(すなわち from nand to tetris)の別名の由来である。

日本人(だけでなく全世界の人)が先んじで進められていて、(特に低レイヤーの)勉強になったという声をよく聞いていたので、文系出身の僕としてもいつかやりたい書籍として手元においていたのだが、このたびGW+有給をうまく使い12連休を錬成してやり遂げたので学びや感想を書こうというである。僕の計算機科学のレベルは応用情報の知識に毛が生えた程度である。

正直かなりきつく、12連休ほぼぶっ通してやっていてようやく完成させました。時間にして多分130時間くらいだと思う(150時間はかかってないと思う)。学びがあったので興味がある人向けにどんな嬉しさがあるのか書きつつ自分の復習をしていきたい。

(完全な余談であるが、完成できるアプリケーションは実はテトリスではなくPongという壁当てゲームである。この事実をこの書籍踏破したほぼ全員が嬉々として指摘している。「テトリス動いて感動したねー!!」とカマをかけて見てもいいかもしれない(何が？))

## 全体像
OSという上位の抽象層がCPUを動かすためにいろいろなレイヤーで変換器を想定するのが良いらしく、前半は回路構築をし、中盤辺りからは各種翻訳機を作るという構成になっている。目次も参考にしつつ全体像を眺めてみよう。

### 前半
* ch1 ブール論理
* ch2 ブール算術
* ch3 順序回路
* ch4 機械語
* ch5 コンピュータアーキテクチャー

一区切りつけるとしたら上の5章分だと思う。ch5で自作のCPUを完成させて簡単な計算から各種キーボードの入力チェック、画面の描画の仕組みまで洗う。

### 中盤
* ch6 アセンブラ

ch5 で完成させたCPUに命令を与えるためには0と1を人力で記述する必要がある。理屈の上ではすでにPongアプリケーションを実行できる。しかし、そのような命令を人間が記述することは事実上不可能である。コンピュータが読み込む言葉の長さ(ワードの幅という)も16が１単位であって記述が大変なことであり、コードの読み直しも大変であるなどの問題が存在するからだ。そこで中盤以降から、「如何に人間に記述しやすいような仕組みを作るか」というフェーズに入る。アセンブラという翻訳機が存在することによって、人間が読み書きしやすいアセンブリ言語 → 機械語へと翻訳することができ、作業スピード・コードの可読性が飛躍的に上昇する。ここではこの翻訳機をゼロから作ろうというのである。

### 後半
* ch7 バーチャルマシン#1: スタック操作
* ch8 バーチャルマシン#2: プログラム制御
* ch9 高水準言語
* ch10 コンパイラ#1:構文解析
* ch11 コンパイラ#2:コード生成

ch6までで作った成果物たちはあくまで自作CPUの上でしか動かない。一般的に考えるとやはりそのようなアーキテクチャーに左右されない計算機は必要である。この問いのひとつの解決策はPC上に仮想の計算機 (Vertual Machine) を作成することで仕様者の環境によらないような計算の方法を確立できる。

また、アセンブラによって命令を扱いやすくなったとはいえ人間が読み書きする想定がなされていない。そこでもう一段高水準な言語を策定し、それをインターフェイスにすることによって複雑な命令を操れるようになる。

この5章を通して高水準言語 → VMプログラム → アセンブリ言語 へと変換でき、ひいては自作のCPUに読み込ませて計算を依頼できるようになる。

### 最終章
* ch12 オペレーティングシステム

ユーザーがPCを使う際、例えば文字を画面に描画することを想定すると、画面のピクセルに関わるメモリはどこに割り当てられるかなど、メモリ等の細かな設計を見なければならない。さらにこれも各アーキテクチャによるルーティンな部分であり、使用者が気にせずに動かせるようにするべきである。そのための最後のレイヤーがオペレーションシステムというわけである。これによりメモリの位置等気にすることなく「画面にhogeを出力せよ」という命令でhogeを出力できるし、「kという入力を認識せよ」という命令で、キーボードの入力に関わるメモリがどこなのかを意識することなく入力できるようになる。かくしてPongアプリを実行できるようになり、本書も終わりである。


## 印象に残っている章
### ch5 コンピュータアーキテクチャー

全体を通して言えることだが、個別の知識として知っていたものを一貫して関連付けできたことが、この本を走破して得られた大きな経験の一つである。そしてCPU周りは特にそうだった。
例えば、今頃のCPUは64bitを１単位として命令を読み込んでいることは知っていたが、それだけでは0と1で具体的にどのように計算しているのかなどわからなかった。また、ノイマン型コンピュータと呼ばれる方式、すなわち「取り出し」「解読」「実行」「読み込み」というプロセスを順々に繰り返していることは知っていたが、やはりhowの部分はbit単位でどのように動いているのか知らなかった。本書で作成できるCPUは１ワード16bitであるという違いがあるものの、その16bitの中でも、各bitがどのような命令の一端を担っているか理解する必要があり、ひいてはその16bitの各bitが内々でどこの回路を通って計算や値の保存に寄与するのかを鮮明に知ることができた。今まで抽象化された回路(それこそより高度なALUなど)を信号が通る図は[パタヘネ本](https://amzn.to/2RSQd3A)等で見てきたが、1bit単位で動きを追うことでそのような抽象化された回路の中まで想像することができ、内容の理解の解像度がグッと高まったのを感じた。

### ch7 ch8 バーチャルマシン

本書で一番好きな章です。すべての命令の順序はスタックの構造で保持でき、そのおかげで命令が格納されたメモリの番地を知る必要がない。僕もCPUの実行はスタックで管理されているという事実は知っていたが、実際にエミュレーターでスタックが増減しながら命令を処理してく姿に感動したし、そもそもスタックで命令を処理できるという事実にただただ圧倒された。無茶な命令を投げると文字通り「スタックがオーバーフロー」する様子を初めて目の辺りにしてこれがスタックオーバーフローか...とある種の感慨に耽ったりした。単純の計算のみならず、関数やクラスのインスタンス与えられた時、どのようにメモリ上に乗せて、そのアドレスをスタックポインタに乗せれば動くのかなどエミュレーター経由で確認でき、大変勉強になった。


### ch10 コンパイラ#1:構文解析

例にももれず理解の解像度が格段に上がった。これまでも木構造として高級言語をパースできることは知っていただが、様々な単位でどう管理しなければならないかがわかった。ただ、正直コンパイラは比較的高レイヤーなのでライター目線どういうものか想定しやすいこともあり、まあそういう翻訳機になるよなというのが正直な感想だった。一方で僕はJavaで書いたのだが、IO周りや正規表現周りの復習になったりで違う学びも多くなにより実装が楽しかったので、久しぶりに寝食忘れてコーディングしていました。

## 総括

繰り返しになるが、一貫して低レイヤーから高レイヤーまでつくるという流れなので、点在する各知識を一貫的に理解できた点が僕の中で一番の収穫だった。特に低レイヤーの挙動を目と手で確認するのはこのような機会を積極的に作らないと得難いのかなと思った。僕の実装の仕方に問題があるのかもしれないが、低レイヤーの組み方が思ったより泥臭いものであることをしれたのも面白かった。

また、本書ではアセンブラ、VM翻訳機、コンパイラという合計3種の変換器を作る必要があるが、これらの作り方は基本的にすべてユーザー次第である(API案は提供されている)。僕はJavaを選択したが、久しぶりにこんなに集中して本格的にプログラミングをできて、競技プログラミングに熱中していた時期を思い出した。僕はマネジメントに近い層で業務をしているが、やっぱりソフトウェア・エンジニアリングは楽しいし、ここで手を動かした体験は今後のプログラミングに対する考え方、自分のキャリアへ影響を与えるだろうなと感じた。

## 不満点、お気持ち、遊び方案

### 説明足りなすぎィ問題

普通に初見で本書のみで課題を完成させるのはほぼ不可能だと思う(気力的にも)。著者らが本書専用のウェブサイトを作ってくれていて、スライド等各種資料もアップロードされているので詰まったり理解の確認がしたかったらスライドも手元に準備することをおすすめします。本に書いてない具体の話も載っていてほとんどマストだなって思いました。

また、先駆者がそれこそ世界規模でいるのでGithub上にたくさんコードが存在しているので、詰まったらGithubでnand2tetrisと検索してみよう。

### 仕様わかりづらすぎィ問題①

公式でAPI案を準備してくれているが、僕目線イマイチそういう設計にしている意図がわからなかった。なんならその意図を把握するのに多くの時間を消費したと思う。他の方のソースコードを参考にさせてもらいつつ自分なりに解釈できたがもっとよりよい方法があるのではと思わずにいられなかった。

具体的にはコンパイラのトークナイザーが状態を持っていたり、APIが過度に外部に公開していたり、2種類のCompiler Engineの差し替えができなかったり、もっとよりよい方法があるのではと感じた。
良し悪しというより、このあたりがWeb屋と純粋なCS屋の哲学の違いなのかなと思った。あとはあえていろいろな言語にも対応できるように幅広に想定した結果なのかなと(なんなら僕がOOPネイティブのJava屋なので具体抽象の話やアクセスに関して敏感になりすぎているだけかもれない。)

逆に言うとこれらは改善の余地とも言える。もっと閉じたAPIを考えたり、クラス間の結合を疎にしてみたり、XML engineと Compiler engineをクラスの差し替えのみで対応できるようにインターフェイスを考えてみたりするのは面白いなと思った。

Web目線といえば、上のengineの差し替えなんてまさにDIや制御の逆転あたりを意識して言っているし、木構造の構築で、子ノードの前後で必ず差し込むような処理が内部で散らかっている(例えば親ノードのタグの開閉など)のをみるとAOPという言葉が脳裏によぎったりした。このあたりを取り込んで全く新しくきれいな設計の翻訳機群を作り直すのはチャレンジングで学びが深そうだと感じた。

API設計や抽象化等Web系エンジニアの腕の見せどころポイントはたくさんありそう。Web屋の力見せてやってくれ...。

### 仕様わかりづらすぎィ問題②

僕の場合はだが、なんか一気に作成して流して大量のエラーをさばく方針で各種翻訳機を作成したし、与えられた説明やAPIに則るとそういう作り方になると思う。ただ、吐き出されるものが低レイヤーのものなのでデバッグがかなりしんどい。だからこそどういうインプットを与えればどのようなアウトプットが得られるのかという情報があればみんなハッピーだと思う。誰か作ってくれ...。ただ、ユニットテストのソースを書いてあげると後続が捗ると思う。

また、こういうものを作るにはTDD的にインクリメンタルに進めていく手法と相性がいいのではと思った。nand2tetris in TDD、誰かやってくれ...。TDDにわか勢だけど普通に勉強になりそう。TDDすすめるために上記のクラス設計見直しができたらWeb屋目線たくさん貢献できるポイントがあると思う。


## 今後の展望

以下本当に雑談です。

低レイヤーで確固たる核ができたこと、今年やりたいリスト(FIFO) の低レイヤー部分が一気に捌けたことでさまざまやりたいことが浮かんできた。

まずはOS部分。正直本書でOS部分を熱心に勉強する気がなく、別機会にがっつりやろうと思っていたので、そのままOSやり始めてもいいかもしれない。最近はいわゆる「[みかん本](https://amzn.to/3eKI3TM)」が評判良く大流行しているのでとりあえず買ってみた。(「[作って理解するOS ](https://amzn.to/3hpljKD)」も手元にあるンだよなぁ)。厚さに圧倒されてペンディング中です...。また、低レイヤーの部分がわかったので難しくて放棄したOSの理論本(「[岩波講座 ソフトウェア科学〈〔環境〕6〉オペレーティングシステム](https://amzn.to/3uPZFmR)」)にでも再チャレンジしてみようかしら。

さらに低レイヤー部分に相当する[パタヘネ本](https://amzn.to/2RSQd3A)の読み直しもしたくなってきた。nand2tetris自身語っていたが、効率化等の話題が省かれているので、並列処理などの話を読み返したくなりました。

お気持ちを述べた通り、nand2tetris自体まだまだ改良の余地があると思っていて、そもそもJavaの勉強にもなったから違う言語で2周めしてみても学びが深そうだ。RustかHaskellでやり直したいなという気持ちがふつふつと湧いている(やるとはいってない)。

## 参考リンク
* nand2tetris 公式ホームページ: https://www.nand2tetris.org/
* Acasuneの作業レポジトリ(全体): https://github.com/Acasune/java-nand2tetris
* Acasuneの作業レポジトリ(JackAnalyzer:ch9に相当): https://github.com/Acasune/Nand2TetrisJackAnalyzer
* Acasuneの作業レポジトリ(JackCompiler:ch10に相当): https://github.com/Acasune/Nand2TetrisJackCompiler
